<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Live2D Viewer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.10/browser/pixi.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/live2dcubismcore@1.0.2/live2dcubismcore.min.js"></script>
  <script src="https://unpkg.com/pixi-live2d-display@0.4.0/dist/cubism4.min.js"></script>
</head>
<style>
  canvas {
    height: 500px;
    object-fit: cover;
  }
</style>
<body style="margin: 0; overflow: hidden; background-color: #282c34">
  <canvas id="canvas" style="margin-top: 100px"></canvas>

  <script>
    let model;
    let mouthFormSeq = [];
    let mouthFormStartTime = null;
    let lastMouthFormHash = "";
    let isSpeaking = false;
    
    // 말하고 있는지 여부 (볼륨 기준)
    let currentVolume = 0;
    const SPEAKING_THRESHOLD = 0.01;
    
    // 입 가로 움직임 범위 제한 (입꼬리 움직임 최소화)
    const DEFAULT_MOUTH_FORM = 1.0;
    const MIN_MOUTH_FORM = 0.4;  // 최소값 (너무 작으면 입꼬리가 내려감)
    const MAX_MOUTH_FORM = 0.8;  // 최대값 (너무 크면 입꼬리가 올라감)

    const app = new PIXI.Application({
      view: document.getElementById("canvas"),
      width: window.innerWidth,
      height: window.innerHeight,
      backgroundColor: 0x282c34,
      resizeTo: window,
    });

    PIXI.live2d.Live2DModel.from(
      "./model/haru/runtime/haru_greeter_t05.model3.json?_=" + Date.now()
    ).then((loadedModel) => {
      model = loadedModel;
      model.scale.set(0.5);
      model.x = app.renderer.width / 2.5;
      model.y = app.renderer.height * 1.5;
      model.anchor.set(0.5, 0.5);
      app.stage.addChild(model);
      
      // 기본 입 모양 설정
      if (model) {
        model.internalModel.coreModel.setParameterValueById("ParamMouthForm", DEFAULT_MOUTH_FORM);
      }

      startVolumeSync();
      startMouthFormSync();
    });

    // 해시 함수 (JSON 내용 비교용)
    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash.toString();
    }

    // 입 가로 길이 립싱크 - 주기적으로 새 데이터 확인
    function startMouthFormSync() {
      // 초기 로드
      fetchMouthFormData();
      
      // 주기적으로 새 mouthForm.json 확인 (200ms마다)
      setInterval(fetchMouthFormData, 200);
      
      // 프레임 동기화 애니메이션 시작
      requestAnimationFrame(syncMouthFormFrame);
    }
    
    // 입 가로 길이 데이터 가져오기
    function fetchMouthFormData() {
      fetch("mouthForm.json?_=" + Date.now())
        .then(res => res.json())
        .then(data => {
          if (!data || !Array.isArray(data) || data.length === 0) return;
          
          const dataHash = simpleHash(JSON.stringify(data));
          
          // 데이터가 변경되었을 때만 업데이트
          if (dataHash !== lastMouthFormHash) {
            console.log("새 입 모양 데이터 로드됨:", data.length + "개");
            mouthFormSeq = data;
            mouthFormStartTime = performance.now();
            lastMouthFormHash = dataHash;
            isSpeaking = true;
          }
        })
        .catch(err => {
          console.warn("입 모양 데이터 로드 실패:", err);
        });
    }

    function syncMouthFormFrame(now) {
      if (!model) {
        requestAnimationFrame(syncMouthFormFrame);
        return;
      }

      // 말하는 중이고 유효한 시퀀스가 있을 때만 적용
      if (isSpeaking && mouthFormSeq && mouthFormSeq.length > 0) {
        const elapsed = (now - mouthFormStartTime) / 1000;
        
        // 현재 시간에 맞는 프레임 찾기
        let current = null;
        for (let i = mouthFormSeq.length - 1; i >= 0; i--) {
          if (mouthFormSeq[i].time <= elapsed) {
            current = mouthFormSeq[i];
            break;
          }
        }

        if (current && typeof current.form === "number") {
          const originalForm = current.form;
          
          // 중요: 입꼬리 움직임 최소화를 위해 값 범위 제한
          // 원래 0.0~1.0 범위에서 MIN~MAX 범위로 압축
          const compressedRange = MAX_MOUTH_FORM - MIN_MOUTH_FORM;
          const mappedForm = MIN_MOUTH_FORM + (originalForm * compressedRange);
          
          // 최종 값: MIN_MOUTH_FORM ~ MAX_MOUTH_FORM 사이로 제한
          const finalForm = Math.max(MIN_MOUTH_FORM, Math.min(mappedForm, MAX_MOUTH_FORM));
          
          // 적용
          model.internalModel.coreModel.setParameterValueById("ParamMouthForm", finalForm);
          
          // 마지막 프레임 이후 1초가 지나면 말하기 종료로 간주
          const lastFrame = mouthFormSeq[mouthFormSeq.length - 1];
          if (lastFrame && elapsed > lastFrame.time + 0.1) {
            console.log("말하기 종료");
            isSpeaking = false;
          }
        }
      } else {
        // 말하지 않을 때는 기본값
        model.internalModel.coreModel.setParameterValueById("ParamMouthForm", DEFAULT_MOUTH_FORM);
        
        // 현재 볼륨이 임계값 이상이면 말하기 시작으로 간주
        if (currentVolume > SPEAKING_THRESHOLD && !isSpeaking) {
          fetchMouthFormData(); // 새로운 데이터 확인
        }
      }

      requestAnimationFrame(syncMouthFormFrame);
    }

    // 볼륨 기반 입 벌림 립싱크
    function startVolumeSync() {
      setInterval(async () => {
        try {
          const res = await fetch("volume.json?_=" + Date.now());
          if (!res.ok) return;
          const { volume } = await res.json();
          
          if (model && typeof volume === "number") {
            currentVolume = volume; // 현재 볼륨 저장
            const mouthOpen = volume > SPEAKING_THRESHOLD ? Math.min(volume * 4.0, 1.0) : 0;
            model.internalModel.coreModel.setParameterValueById("ParamMouthOpenY", mouthOpen);
            
            // 볼륨에 따라 말하기 상태 업데이트
            if (volume > SPEAKING_THRESHOLD && !isSpeaking) {
              fetchMouthFormData(); // 새로운 립싱크 데이터 확인
            }
          }
        } catch (e) {
          console.warn("볼륨 동기화 실패:", e);
        }
      }, 50);
    }
  </script>
</body>
</html>